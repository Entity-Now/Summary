import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,a as e}from"./app-4bfb80fa.js";const t={},o=e(`<h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h1><h2 id="双冒号-运算符的作用" tabindex="-1"><a class="header-anchor" href="#双冒号-运算符的作用" aria-hidden="true">#</a> 双冒号<code>::</code>运算符的作用</h2><p>在Kotlin中，双冒号运算符&quot;::&quot;用于引用函数、属性或类。它有两个主要的用途：</p><ol><li>函数引用：双冒号运算符可以用于引用一个函数，而不调用它。这对于将函数作为参数传递或将函数赋值给变量非常有用。例如，考虑以下函数：</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Hello, World!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以使用双冒号运算符来引用这个函数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> functionRef <span class="token operator">=</span> <span class="token operator">::</span>hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，<code>functionRef</code>变量持有了对<code>hello</code>函数的引用，你可以稍后通过调用<code>functionRef()</code>来执行它。</p><ol start="2"><li>类引用：双冒号运算符也可以用于引用类。这在反射和泛型等场景下非常有用。例如，考虑以下类：</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你可以使用双冒号运算符来引用这个类：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> classRef <span class="token operator">=</span> Person<span class="token operator">::</span><span class="token keyword">class</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，<code>classRef</code>变量持有了对<code>Person</code>类的引用。你可以使用<code>classRef</code>来获取类的相关信息，或者创建类的实例。</p><p>总而言之，双冒号运算符在Kotlin中用于引用函数、属性或类，它提供了一种简洁的方式来获取对它们的引用，而不执行它们。</p><h2 id="with、apply、run、let用法" tabindex="-1"><a class="header-anchor" href="#with、apply、run、let用法" aria-hidden="true">#</a> with、apply、run、let用法</h2><p>在Kotlin中，有几个标准库函数（Standard Library Functions）可以用于简化对象操作和作用域内的代码块。以下是其中一些常用的函数以及它们的说明：</p><ol><li><p>let： <code>let</code>函数是针对一个对象执行特定的操作，并且可以在操作过程中引用该对象。它接收一个lambda表达式作为参数，该lambda表达式将当前对象作为参数传递，并在lambda表达式内部对该对象进行操作。<code>let</code>函数的返回值是lambda表达式的结果。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> result <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 对象操作</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token comment">// 返回结果</span>
    result
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>apply： <code>apply</code>函数用于对对象进行配置操作。它接收一个lambda表达式作为参数，在lambda表达式内部可以对对象进行一系列的属性配置操作。<code>apply</code>函数的返回值是该对象本身。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> obj <span class="token operator">=</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对象配置</span>
    property1 <span class="token operator">=</span> value1
    property2 <span class="token operator">=</span> value2
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>run： <code>run</code>函数类似于<code>let</code>函数，但它可以在lambda表达式内部访问该对象的成员函数而不仅限于属性。它接收一个lambda表达式作为参数，将当前对象作为接收者（receiver）传递给lambda表达式，并在lambda表达式内部对该对象进行操作。<code>run</code>函数的返回值是lambda表达式的结果。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> result <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">run</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 对象操作</span>
    <span class="token function">memberFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token comment">// 返回结果</span>
    result
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>with： <code>with</code>函数类似于<code>run</code>函数，但是它不是一个扩展函数，而是一个顶层函数。它接收一个对象和一个lambda表达式作为参数，并在lambda表达式内部对该对象进行操作。<code>with</code>函数的返回值是lambda表达式的结果。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token function">with</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 对象操作</span>
    <span class="token function">memberFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token comment">// 返回结果</span>
    result
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>这些函数在不同的场景中有不同的用途，但它们的共同点是可以简化对象操作和作用域内的代码块。你可以根据具体的需求选择适当的函数来使用。</p><h2 id="高阶函数" tabindex="-1"><a class="header-anchor" href="#高阶函数" aria-hidden="true">#</a> 高阶函数</h2><p>高阶函数是一种能够接受函数作为参数或返回函数作为结果的函数。换句话说，它可以将函数作为参数传递给其他函数，或者从函数中返回另一个函数。</p><p>在 Kotlin 中，函数是一等公民，可以像任何其他类型的值一样进行操作。这使得高阶函数成为可能，可以通过函数参数和函数类型来实现更加灵活和可复用的代码。</p><p>以下是一个简单的例子来说明高阶函数的概念：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">calculate</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Int<span class="token punctuation">,</span> b<span class="token operator">:</span> Int<span class="token punctuation">,</span> operation<span class="token operator">:</span> <span class="token punctuation">(</span>Int<span class="token punctuation">,</span> Int<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Int<span class="token punctuation">,</span> b<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">subtract</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Int<span class="token punctuation">,</span> b<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> result1 <span class="token operator">=</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">::</span>add<span class="token punctuation">)</span> <span class="token comment">// 使用 add 函数作为参数</span>
    <span class="token function">println</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span> <span class="token comment">// 输出：8</span>

    <span class="token keyword">val</span> result2 <span class="token operator">=</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">::</span>subtract<span class="token punctuation">)</span> <span class="token comment">// 使用 subtract 函数作为参数</span>
    <span class="token function">println</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span> <span class="token comment">// 输出：6</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，<code>calculate</code> 函数是一个高阶函数，它接受两个整数参数 <code>a</code> 和 <code>b</code>，以及一个函数类型的参数 <code>operation</code>，该函数类型接受两个整数参数并返回一个整数。</p><p><code>calculate</code> 函数内部调用传递进来的 <code>operation</code> 函数，并将 <code>a</code> 和 <code>b</code> 作为参数传递给它。这样，我们可以根据不同的需求传递不同的操作函数，例如 <code>add</code> 和 <code>subtract</code>。</p><p>在 <code>main</code> 函数中，我们分别调用 <code>calculate</code> 函数，传递 <code>add</code> 函数和 <code>subtract</code> 函数作为参数。<code>add</code> 函数会将两个参数相加，而 <code>subtract</code> 函数会将第一个参数减去第二个参数。</p><p>通过高阶函数，我们可以更灵活地组合和重用函数。它使得函数能够以更抽象和通用的方式进行操作，从而提高代码的可读性和可维护性。</p><h3 id="高阶函数小技巧" tabindex="-1"><a class="header-anchor" href="#高阶函数小技巧" aria-hidden="true">#</a> 高阶函数小技巧</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>&quot;print hello world~&quot;.also(::println)</code> 此段代码可以正确打印字符串吗？</p></div><p>是的，这段代码可以成功打印文字。</p><p>当你将函数引用作为参数传递给高阶函数（如 also、apply、run、let 等）时，高阶函数会将函数引用作为 lambda 表达式的参数进行调用。</p><p>在这个特定的例子中，&quot;print hello world~&quot; 是一个字符串，而 ::println 是对顶层函数 println 的引用。::println 接受一个参数，并在控制台上打印出该参数。</p><p>当你使用 also、apply、run 或 let 将 ::println 作为参数传递时，它们会将 &quot;print hello world~&quot; 作为参数传递给 ::println，然后执行 ::println 所引用的函数，从而将该参数打印到控制台上。</p><p>因此，::println 能够正确接收前面的字符串，是因为它是对 println 函数的引用，并在高阶函数中作为 lambda 表达式的参数进行调用。</p><h2 id="constructor构造函数与init有什么区别" tabindex="-1"><a class="header-anchor" href="#constructor构造函数与init有什么区别" aria-hidden="true">#</a> constructor构造函数与init有什么区别</h2><p>在 Kotlin 中，<code>init</code> 块和构造函数是用来初始化类的成员的两种不同方式。</p><ol><li><p>构造函数：构造函数是用于创建类的实例的特殊函数。在 Kotlin 中，主要有两种类型的构造函数：主构造函数和次构造函数。</p><ul><li><p>主构造函数：主构造函数是类头的一部分，并跟在类名后面。它可以包含参数，这些参数可以在类的初始化过程中使用。主构造函数可以通过参数来初始化类的属性。</p></li><li><p>次构造函数：次构造函数是可选的，可以有多个。它们是通过 <code>constructor</code> 关键字定义的辅助构造函数。次构造函数可以用来提供额外的构造方式，但不能直接初始化属性。</p></li></ul><p>例如：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Initializing Person object&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Secondary constructor called with name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string"> and age: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">age</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>init</code> 块：<code>init</code> 块是一个特殊的初始化块，在创建类的实例时执行。它用于执行类的初始化逻辑，可以在其中初始化属性、执行其他操作等。一个类可以有多个 <code>init</code> 块，它们按照顺序执行。</p><p>例如：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Initializing Person object&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Performing additional initialization&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，当创建 <code>Person</code> 对象时，<code>init</code> 块中的代码会按顺序执行。在 <code>init</code> 块中，你可以访问和操作类的属性，以及执行其他初始化操作。</p></li></ol><p>总结：</p><ul><li>构造函数用于创建类的实例，并可以在初始化过程中使用参数初始化属性。</li><li><code>init</code> 块是一个初始化块，用于在创建类的实例时执行额外的初始化逻辑，可以访问和操作类的属性。</li><li>类可以有主构造函数和多个次构造函数，而 <code>init</code> 块是类级别的初始化块，可以有多个。</li><li>构造函数和 <code>init</code> 块可以同时存在，它们按照一定的顺序执行，构造函数首先执行，然后才是 <code>init</code> 块。</li></ul>`,39),p=[o];function l(c,i){return s(),a("div",null,p)}const r=n(t,[["render",l],["__file","other.html.vue"]]);export{r as default};
